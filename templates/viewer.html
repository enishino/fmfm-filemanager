<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>{{ data['title'] }}</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet">
<style>
nav.hidden {
    opacity: 0.0
}

nav:hover {
    opacity: 0.8
}

div.parent {
    position:relative;
}
div.menu {
    position: absolute;
    float: left;
    left: 0;
    right: 0;
    margin: auto;
}

.flashes {
    position: absolute;
    float: left;
}

@keyframes fade-out {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

.fade-out {
  animation: fade-out 2s 1;
  animation-fill-mode: both;
}

</style>
</head>
<body>
<div class="parent">

<!-- Flash error messages-->
{% with messages = get_flashed_messages(with_categories=true) %}
  {% if messages %}
    <ul class="flashes fade-out">
    {% for category, message in messages %}
      <li class="{{ category }}">{{ message }}</li>
    {% endfor %}
    </ul>
  {% endif %}
{% endwith %}

<div class="menu">
<nav class="navbar navbar-expand-sm navbar-dark bg-dark sticky-top hidden">

    <div class="navbar-left flex-grow-1">
        <ul class="navbar-nav">
            <!-- Back -->
            <li class="nav-item nav-link">
                <a class="nav-link text-secondary" href="{{ prev_url }}">Back</a>
            </li>
            <!-- Edit -->
            <li class="nav-item nav-link">
                <a class="btn btn-secondary" role="button" href="{{ url_for('edit_fileinfo', number=data['number']) }}">
                    Edit
                </a>
            </li>
            <!-- Page slider -->
            <li class="nav-item d-flex align-items-center flex-grow-1">
                <input type="range" class="form-range pagecontrol" min="0" max="{{ data['pagenum'] - 1 }}" step="1" id="pagecontrol" value="0" onChange="pagemove('both', pos=this.value); redraw(); this.blur()" />
            </li>
            <!-- Page shifter -->
            <li class="nav-item d-flex align-items-center">
                <input type="checkbox" class="btn-check" id="pageshift" autocomplete="off"
                onClick="list_init(); pagemove('both', pos=image_handler.current()), redraw(); this.blur()"
                {% if not data['spread'] %} disabled {% endif %} />
                <label class="btn btn-outline-primary" for="pageshift">Shift</label>
            </li>
            <!-- Download -->
            <li class="nav-item nav-link">
                <a class="btn btn-success" role="button" href="{{ url_for('raw',number=data['number']) }}">
                    Download
                </a>
            </li>
        </ul>
    </div>

</nav>
</div>

</div>

<canvas id="canvas" width="2040" height="1200" style="width:1020px; height:600px"></canvas>
</div>

<script>
// Todo: if the screen width < height, turn off spread and reload (possible?)

// Common config (global, won't be changed in a session)'
var img_list = [];
var start_from = {{ start_from }}
var spread = {{ data['spread'] }}
var r2l = {{ data['r2l'] }}
var pagecontroller = document.getElementById("pagecontrol");

// Canvas drawing
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var expansion = 3.0; // internal resolution per canvas size

file_list = Array.from(Array({{ data['pagenum'] }}), (v, k) => "/img/{{ data['number'] }}/" + k)

//// ---- Image list handling ---- ////
// Image list creation and modification
function list_init() {
  pageshift = document.getElementById("pageshift").checked;

  img_list = file_list.concat();
  if (pageshift) {
    if (r2l) {
      img_list.push(null);
    } else {
      img_list.unshift(null);
    }
  }

  // [Interface] Paging interface tempering
  if (spread) {
    pagecontroller.step = 2;
    if (img_list.length % 2 == 0) {
      pagecontroller.max = img_list.length - 2;
    } else {
      pagecontroller.max = img_list.length - 1;
    }
  }

  // [Start position]
  // [R2L] direction reversing ... next/prev means now <- and -> for image number (not array pos).
  if (r2l) {
    img_list.reverse();
    start_from = img_list.length - 1 - start_from;
  }

  start_from = sane_position(start_from);

  // [Spread] when p.1 specified and 0/1 is shown, the starting point should be 0
  // also applied with page shifted condition with even starting point.
  if ((spread && start_from % 2 != 0) || (spread && pageshift && start_from % 2 == 0)) {
    start_from -= 1;
  }
}

function sane_position(pos) {
  // [Foolproof] Position overflow fix
  if (pos > img_list.length - 1) {
    pos = img_list.length - 1;
  }
  if (pos < 0) {
    pos = 0;
  }
  return pos;
}

// Image path handler
// This considers just a position (index) in a image list (not r2l direction)
// l[0] is edge of the "left" side, l[-1] is of the "right" side.
var image_handler = (function () {
  if (!this.awake) {
    var pos = 0;
    this.awake = true;
  }

  function move(val) {
    pos += val;
    pos = sane_position(pos)
  }

  return {
    next: function () {
      if (spread) {
        if (pos < img_list.length - 2) {
            move(2);
        }
      } else {
        move(1);
      }
    },
    prev: function () {
      if (spread) {
        move(-2);
      } else {
        move(-1);
      }
    },
    set_pos: function (abs_pos) {
      pos = sane_position(parseInt(abs_pos))
    },
    path: function () {
      if (spread) {
        return [img_list[pos], img_list[pos + 1]];
      } else {
        return [img_list[pos], null];
      }
    },
    current: function () {
      return pos;
    },
  };
})();

//// ---- Image obtaining ---- ////
// Delay loading
async function delayloader(srcs) {
  let result = []
  for (let i=0; i<srcs.length; i++) {
    if (srcs[i]) {
      var img = new Image()
      img.src = srcs[i]
      await img.decode().catch(console.error) // Wait for loading
      result.push(img)
    } else {
      // Invalid src
      result.push(null)
    }
  }
  return result
}

// Image preloading
async function preload(pos, direction, size = 4) {
  if (direction == "forward") {
    _list = img_list.slice(pos, pos + size);
  } else {
    _list = img_list.slice(pos - size, pos);
  }
  preload_imgs = await delayloader(_list);
}

//// ---- Interfacing ---- ////
// Page moving wrapper
function pagemove(direction, pos = null) {
  if (pos) {
    image_handler.set_pos(pos);
  } else {
    if (direction == "next") {
      image_handler.next();
    } else if (direction == "prev") {
      image_handler.prev();
    }
  }

  // Take current position (set in above code)
  pos = image_handler.current();
  pagecontroller.value = pos;
  redraw();

  // Preload
  if (direction == "next" || direction == "both") {
    preload(pos, "forward");
  }
  if (direction == "prev" || direction == "both") {
    preload(pos, "back");
  }
}

// Click interface
canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const point = {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top,
  };
  if (canvas.width - point.x * expansion > canvas.width / 2) {
    pagemove("prev");
  } else {
    pagemove("next");
  }
});

// Keyboard interface
// Todo: use https://developer.mozilla.org/en-US/docs/Web/API/Keyboard/getLayoutMap
function keyboardEvent(event) {
  if (event.type === "keydown" && event.code === "ArrowLeft") {
    pagemove("prev");
  }
  if (event.type === "keydown" && event.code === "ArrowRight") {
    pagemove("next");
  }
  if (event.type === "keydown" && event.code === "Escape") {
    history.back();
  }
  if (event.type === "keydown" && event.code === "KeyQ") {
    history.back();
  }
}
addEventListener("keydown", keyboardEvent);

// Wheel triggers the page movement.
function wheelEvent(event) {
  if (event.type === "wheel") {
    // The point is that user don't want to reverse the wheel direction!
    // So here the direction is reversed when R2L is on.
    if (r2l) {
      dY = -event.deltaY;
    } else {
      dY = event.deltaY;
    }
    if (dY < 0) {
      pagemove("prev");
    } else {
      pagemove("next");
    }
  }
}
addEventListener("wheel", wheelEvent);

// When window size changes the canvas will be changed
window.onresize = redraw;

//// ---- Drawing  ---- ////
// Drawing to canvas func.
async function draw(src1, src2) {
  // Changes the cursor
  canvas.style.cursor = "wait";

  let img1, img2
  [img1, img2] = await delayloader([src1, src2]);

  if (img1 && img2) {
    w1 = img1.width * (canvas.height / img1.height);
    w2 = img2.width * (canvas.height / img2.height);
    ctx.drawImage(img1, (canvas.width - w1 - w2) / 2, 0, w1, canvas.height);
    ctx.drawImage(img2, w1 + (canvas.width - w1 - w2) / 2, 0, w2, canvas.height);

  } else if (img1 || img2) {
    img_single = img1 || img2;
    w_img = img_single.width * (canvas.height / img_single.height);
    ctx.drawImage(img_single, (canvas.width - w_img) / 2, 0, w_img, canvas.height);

  } else {
    console.log("No images are found.");
  }

  // Get back the cursor
  canvas.style.cursor = "auto";
}

// Drawing wrapper
// Todo(bug): this drawing a bit exceeds iPad's screen.
function redraw() {
  // change canvas size
  // I've got why this works from https://teratail.com/questions/67020
  c_width = document.documentElement.clientWidth - 10;
  c_height = document.documentElement.clientHeight - 10;
  canvas.style.width = c_width + "px";
  canvas.style.height = c_height + "px";
  canvas.width = c_width * expansion;
  canvas.height = c_height * expansion;

  // get image path
  let src1, src2;
  [src1, src2] = image_handler.path();
  draw(src1, src2);
}

//// ---- Initialization ---- ////
// Image list preparation
list_init();

// Start position is set
image_handler.set_pos(start_from);
pagecontroller.value = start_from;

// Preload both direction (start from middle)
preload(start_from, "forward");
preload(start_from, "back");

// Draw the canvas
redraw();

</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
</body>
</html>
