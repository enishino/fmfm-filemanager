<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>{{ data['title'] }}</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet">
<style>
nav.hidden {
    opacity: 0.0
}

nav:hover {
    opacity: 0.8
}

div.parent {
    position:relative;
}
div.menu {
    position: absolute;
    float: left;
    left: 0;
    right: 0;
    margin: auto;
}

.flashes {
    position: absolute;
    float: left;
}

@keyframes fade-out {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

.fade-out {
  animation: fade-out 2s 1;
  animation-fill-mode: both;
}

</style>
</head>
<body>
<div class="parent">

<!-- Flash error messages-->
{% with messages = get_flashed_messages(with_categories=true) %}
  {% if messages %}
    <ul class="flashes fade-out">
    {% for category, message in messages %}
      <li class="{{ category }}">{{ message }}</li>
    {% endfor %}
    </ul>
  {% endif %}
{% endwith %}

<div class="menu">
<nav class="navbar navbar-expand-sm navbar-dark bg-dark sticky-top hidden">

    <div class="navbar-left flex-grow-1">
        <ul class="navbar-nav">
            <!-- Back -->
            <li class="nav-item nav-link">
                <a class="nav-link text-secondary" href="{{ prev_url }}">Back</a>
            </li>
            <!-- Edit -->
            <li class="nav-item nav-link">
                <a class="btn btn-secondary" role="button" href="{{ url_for('edit_fileinfo', number=data['number']) }}">
                    Edit
                </a>
            </li>
            <!-- Page slider -->
            <li class="nav-item d-flex align-items-center flex-grow-1">
                <input type="range" class="form-range pagecontrol" min="0" max="{{ data['pagenum'] - 1 }}" step="1" id="pagecontrol" value="0" onChange="pagemove('both', pos=this.value); redraw(); this.blur()" />
            </li>
            <!-- Page shifter -->
            <li class="nav-item d-flex align-items-center">
                <input type="checkbox" class="btn-check" id="pageshift" autocomplete="off"
                onClick="list_init(); redraw(); this.blur()"
                {% if not data['spread'] %} disabled {% endif %} />
                <label class="btn btn-outline-primary" for="pageshift">Shift</label>
            </li>
            <!-- Download -->
            <li class="nav-item nav-link">
                <a class="btn btn-success" role="button" href="{{ url_for('raw',number=data['number']) }}">
                    Download
                </a>
            </li>
        </ul>
    </div>

</nav>
</div>

</div>

<canvas id="canvas" width="2040" height="1200" style="width:1020px; height:600px"></canvas>
</div>

<script>
// Todo: if the screen width < height, turn off spread and reload (possible?)

// Common config (global, won't be changed in a session)'
var img_list = []
var start_from = {{ start_from }}
var spread = {{ data['spread'] }}
var r2l = {{ data['r2l'] }}
var pagecontroller = document.getElementById('pagecontrol')

// Canvas drawing
var canvas = document.getElementById("canvas")
var ctx = canvas.getContext('2d');
var expansion = 3.0 // internal resolution per canvas size

file_list = Array.from(Array({{ data['pagenum'] }}), (v, k) => "/img/{{ data['number'] }}/" + k)


//// ---- Image list handling ---- ////
// Image list creation and modification
function list_init(){
    pageshift = document.getElementById("pageshift").checked

    img_list = file_list.concat()
    if (pageshift) {
        if (r2l) {
            img_list.push(null)
        } else {
            img_list.unshift(null)
        }
    }

    // [Interface] Paging interface tempering
    // Todo(bug): when switch back from shift to nonshift at first page on R2L, the page will be blank.
    if (spread) {
        pagecontroller.step = 2
        if (img_list.length % 2 == 0) {
            pagecontroller.max = img_list.length - 2
        } else {
            pagecontroller.max = img_list.length - 1
        }
    }

    // [Start position]
    // [R2L] direction reversing ... next/prev means now <- and -> for image number (not array pos).
    if (r2l) {
        img_list.reverse()
        start_from = img_list.length-1 - start_from
    }

    start_from = position_fixer(start_from)
}

function position_fixer(pos) {
    // [Foolproof] Position overflow fix
    if (pos > img_list.length-1) {
        console.log('position overflow')
        pos = img_list.length-1
    }
    if (pos < 0) {
        console.log('position underflow')
        pos = 0
    }

    // [Spread] when p.1 specified and 0/1 is shown, the starting point should be 0
    // also applied with page shifted condition with even starting point.
    if (spread && pos % 2 != 0) {
        pos -= 1;
    } else if (spread && pageshift && pos % 2 == 0) {
        pos -= 1;
    }
    return pos
}

// Image path handler
// This considers just a position (index) in a image list (not r2l direction)
// l[0] is edge of the "left" side, l[-1] is of the "right" side.
var image_handler = (function() {
    if (this.awake) {
        void(0)
    } else {
        var pos = 0
        this.awake = true
    }

    function move(val) {
        pos += val;
    }
    return {
        next: function() {
            if (spread && pos < img_list.length - 2) {
                move(2)
            } else if (!spread && pos < img_list.length - 1) {
                move(1)
            }
        },
        prev: function() {
            if (spread && pos - 1 > 0) {
                move(-2)
            } else if (!spread && pos > 0) {
                move(-1);
            }
        },
        set_pos: function(abs_pos) {
            if (abs_pos >= 0 && abs_pos < img_list.length) {
                pos = parseInt(abs_pos)
            }
        },
        path: function() {
            if (spread) {
                return [img_list[pos], img_list[pos + 1]];
            } else {
                return [img_list[pos], null];
            }
        },
        current: function() {
            return pos
        },
    };
})();


//// ---- Image obtaining ---- ////
// Image preloading *** REFACT, not boilerplate ***
/// This can load "previous" files by specifying minus value.
/// This function knows only image list, not for direction (r2l).
/// (When normal: l[0] = 001.png, l[1] = 002.png, ...)
/// (When R2L: l[0] = 127.png, l[1] = 126.png, ...)
/// ... So when r2l is on, "successive" = "previous" preloading is done with minus size.
async function preload(pos, size) {
    if (size > 0) {
        for (let i = pos; i < pos + size; i++) {
            if (i < img_list.length && img_list[i]) {
                var _ = new Image()
                _.src = img_list[i]
                await _.decode().catch(console.error)
            }
        }
    } else {
        for (let i = pos; i > pos + size; i--) {
            if (i >= 0 && img_list[i]) {
                var _ = new Image()
                _.src = img_list[i]
                await _.decode().catch(console.error)
            }
        }
    }
}


//// ---- Interfacing ---- ////
// Page moving wrapper
function pagemove(direction, pos=null) {
    //console.log(direction, 'is called')
    if (pos) {
        image_handler.set_pos(pos) 
    } else {
      if (direction=='next') { image_handler.next(); }
      else if (direction=='prev') { image_handler.prev(); }
    }

    pos = image_handler.current();
    pagecontroller.value = pos
    redraw()

    if (direction=='next') { preload(pos, 4); }
    else if (direction=='prev') { preload(pos, -4); }
    else if (direction=='both') { preload(pos, -4); preload(pos, 4); }
}

// Click interface
canvas.addEventListener("click", e => {
    const rect = canvas.getBoundingClientRect();
    const point = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
    if ((canvas.width - point.x * expansion) > canvas.width / 2) {
        pagemove("prev")
    } else {
        pagemove("next")
    }
});

// Keyboard interface
// Todo: use https://developer.mozilla.org/en-US/docs/Web/API/Keyboard/getLayoutMap
function keyboardEvent(event) {
    if(event.type === "keydown" && event.code === "ArrowLeft") {
        pagemove("prev")
    }
    if (event.type === "keydown" && event.code === "ArrowRight") {
        pagemove("next")
    }
    if (event.type === "keydown" && event.code === "Escape") {
        history.back()
    }
    if (event.type === "keydown" && event.code === "KeyQ") {
        history.back()
    }
}
addEventListener("keydown", keyboardEvent);

// Wheel triggers the page movement.
function wheelEvent(event) {
    if(event.type === "wheel") {
        // The point is that user don't want to reverse the wheel direction!
        // So here the direction is reversed when R2L is on.
        if (r2l) { dY = -(event.deltaY) } else { dY = event.deltaY }
        if (dY < 0) { pagemove("prev") } else { pagemove("next") }
    }
}
addEventListener("wheel", wheelEvent);

// When window size changes the canvas will be changed
window.onresize = redraw


//// ---- Drawing  ---- ////
// Drawing to canvas func.
async function draw(src1, src2) {
    // Changes the cursor
    canvas.style.cursor = "wait";

    // let img1, img2
    if (src1) {
        var img1 = new Image()
        img1.src = src1
        await img1.decode().catch(console.error)
    }
    if (src2) {
        var img2 = new Image()
        img2.src = src2
        await img2.decode().catch(console.error)
    }

    if (img1 && img2) {
        w1 = img1.width * (canvas.height / img1.height)
        w2 = img2.width * (canvas.height / img2.height)
        ctx.drawImage(img1,    (canvas.width - w1 - w2)/2, 0, w1, canvas.height)
        ctx.drawImage(img2, w1+(canvas.width - w1 - w2)/2, 0, w2, canvas.height)

    } else if (img1 || img2) {
        img_single = img1 || img2
        w_img = img_single.width * (canvas.height / img_single.height)
        ctx.drawImage(img_single, (canvas.width - w_img)/2, 0, w_img, canvas.height)

    } else {
        console.log("No images are found")

    }

    // Get back the cursor
    canvas.style.cursor = "auto";
}

// Drawing wrapper
// Todo(bug): this drawing a bit exceeds iPad's screen.
function redraw(){
    // change canvas size
    // I've got why this works from https://teratail.com/questions/67020
    c_width = document.documentElement.clientWidth - 10;
    c_height = document.documentElement.clientHeight - 10;
    canvas.style.width = c_width + "px"
    canvas.style.height = c_height + "px"
    canvas.width = c_width * expansion
    canvas.height = c_height * expansion

    // get image path
    let src1, src2
    [src1, src2] = image_handler.path()
    draw(src1, src2)
}


//// ---- Initialization ---- ////
// Image list preparation
list_init()

// Start position is set
image_handler.set_pos(start_from)
pagecontroller.value = start_from

// Preload the next image
if (r2l) { preload(start_from, -4) } else { preload(start_from, 4) }

// Draw the canvas
redraw()

</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
</body>
</html>
